[
  {
    "path": "posts/2020-03-20-learn-to-code/",
    "title": "Teach yourself to Code",
    "description": "",
    "author": [
      {
        "name": "Kelly L. Sovacool",
        "url": "https://sovacool.dev/"
      },
      {
        "name": "Zena M. Lapp",
        "url": "https://zenalapp.github.io"
      }
    ],
    "date": "2020-03-20",
    "categories": [
      "R",
      "Python"
    ],
    "contents": "\n\nContents\nWhy learn to code?\nWhat language to learn?\nHow to get started?\nHow to use it in the real world?\nHow to get help?\nFurther reading:\n\n\nThis post was originally published on the DANG! blog\nAs most lab work at the University of Michigan comes to a temporary halt due to the ongoing COVID-19 pandemic, we‚Äôve heard some of our fellow grad students and other researchers express an interest in learning how to code as they‚Äôre not able to conduct experimental work at this time. We thought we could help out by putting together this short guide on how to teach yourself to code.\nFirst above all, take care of yourself and your loved ones! We don‚Äôt want to contribute to the voices pressuring academics to be productive at a time when we should all be prioritizing our mental and physical health and that of our families. If you also have found the motivation and time to teach yourself how to code, then this guide is for you.\nWe wrote this guide with grad students, postdocs, and other scientists who have never written code before in mind, but most of the content applies to just about anyone wanting to learn.\n\nüì£ UPDATE 25 Mar.¬†2020: Pat Schloss is running a weekly Code Club via Zoom for those who want to learn R and improve their data analysis skills. All experience levels are welcome! See details here: riffomonas.org/code_club.\n\nWhy learn to code?\nPerform exploratory data analysis.\nAnalyze & visualize your data.\nCreate automated reports.\nAutomate everything.\nMake your work reproducible.\nCreate publication-quality figures.\nWhat language to learn?\nIf there‚Äôs a single popular language that everyone else in your lab, department, or field uses, just start with that one. Why? You will want to be able to learn from others and ask for help when you need it. For scientific research, both R and Python are popular languages and great for getting started quickly with data analysis. R and Python are open source, meaning they are free as in libre and free as in free food at the department seminar! So you don‚Äôt need to buy a license to use them, you‚Äôll have access after you leave the university, and anyone else with a computer will be able to run your code too.\nScientists in the DANG! community use R, Python, and/or other languages, but R seems to be the most common. If you‚Äôre not sure which one to pick and you‚Äôd like to get help from the DANG! community, try R. We also particularly like R for a package called R Markdown for turning code into analysis reports, manuscripts, and even presentations to easily & reproducibly share our work with others.\nThe logic of programming is the most important thing to learn, so deciding to pick up another language once you have experience in one should be easier. And it‚Äôs definitely not an ‚Äúeither/or‚Äù scenario; many experienced programmers use multiple languages regularly in their work. However, we recommend sticking to learning just one language at first so you don‚Äôt get overwhelmed.\nHow to get started?\nCode Academy is a good place to start for their free beginner R and Python lessons in an interactive format. Note that the free version of the Python lessons teach Python 2 (not Python 3). You should definitely use Python 3 if you‚Äôre going to use Python in your work, but there are very few differences in how you code Python 2 and 3, so learning Python 2 is still very valuable because almost everything translates to using Python 3.\nZena and her sister Maya created a guide to teaching yourself R. It takes you through the Code Academy lesson and also has extra exercises to practice data analysis.\nThe Carpentries is an organization that holds workshops to teach introductory programming skills to researchers. U-M has a Carpentries chapter that holds workshops regularly throughout the year (with the exception of during pandemics üò¨). We highly recommend attending an in-person workshop if you get the opportunity, but you can access the lesson materials for R and Python online if you‚Äôd like to learn on your own. The Carpentries has also translated their R lesson to Spanish.\nAs part of Girls Who Code at U-M, Zena and Kelly have contributed to a curriculum teaching Python for Data Science aimed at high school students. You can find instructions for getting started here.-\nRStudio has interactive tutorials where you can learn everything from the basics to writing reports to building interactive web apps.\nIf you‚Äôve exhausted these options, here‚Äôs an overwhelmingly long list of links to even more resources and tools you might like to learn.\nHow to use it in the real world?\nIf you want to automate tasks, run your code on supercomputers, and make your friends think you‚Äôre a hacker, you should definitely learn the Unix Shell. You can find The Carpentries‚Äô lesson on the Unix Shell here.\nThe Carpentries has instructions for installing the tools you‚Äôll need: - Python - R - Unix Shell\nHow to get help?\nGoogle is your best friend. No, really. We Google questions every day!\nAsk your friends, colleagues, etc. Especially when you‚Äôre just starting out, it can be difficult to know what to Google to get the answers you need. Ask a more advanced programmer as soon as you hit a wall.\nJoin the DANG! Slack workspace and use the #analysis_questions channel. DANG! exists because we think it‚Äôs important to have a community of practice so you can learn from other people, get personalized help when you need it, and help others.\nFurther reading:\nTen simple rules for biologists learning to program\nSuck until you don‚Äôt\nWritten by Zena Lapp & Kelly Sovacool. Edited by Ari Kozik.\n\n\n\n",
    "preview": {},
    "last_modified": "2021-04-28T16:30:37-04:00",
    "input_file": "2020-03-20-learn-to-code.utf8.md"
  },
  {
    "path": "posts/2019-12-19-urssi-winterschool-notes/",
    "title": "URSSI Winter School",
    "description": "My notes from the URSSI Winter School",
    "author": [],
    "date": "2019-12-19",
    "categories": [
      "Research Software Engineering",
      "Open Source Software",
      "Reproducibility",
      "Software Development",
      "Python",
      "git"
    ],
    "contents": "\n\nContents\nDay 1Intro to Software Design (Jeffrey Carver)\nThink like a programmer (Andy Loftus)\nIntro to Design Patterns (Jeffrey Carver)\nBasics of packaging Python programs (Kyle Niemeyer)\n\nDay 2Collaboration with Git and GitHub (Karthik Ram)\nGit Exercises (James Howison)\nSoftware Testing and Continuous Integration (Kyle Niemeyer)\nGit Exercises ctd (James Howison)\n\nDay 3Code Review (Jeffrey Carver)\nOpen Science and Software Citation (Kyle Niemeyer)\nReproducibility\nDocumentation (Kyle Niemeyer)\n\n\nAll slides & other resources are available on GitHub: si2-urssi/winterschool\nDay 1\nIntro to Software Design (Jeffrey Carver)\nWhether you know it or not, you‚Äôre doing software design. Make those decisions with intent & purpose.\nCharacteristics of good design\nFirmness: hard to write bugs accidentally\nSuitable for intended purpose\nInteresting & useful to users\n\nPrinciples of design:\nTraceability - easy to understand what the software is supposed to do.\nMinimize intellectual distance - as close to the real-world as possible\nDon‚Äôt reinvent the wheel. Re-use good design if it‚Äôs already a solved problem.\nAccommodate change.\nFail gracefully.\n\nThink like a programmer (Andy Loftus)\nSolve easy problems; defer hard ones until they are easy.\nZen of Python (import this) excerpt: ‚ÄúIf the implementation is hard to explain, it‚Äôs a bad idea. If the implementation is easy to explain, it may be a good idea.‚Äù\n\nThink about code before you write it\nIdentify use cases\nDefine goals from use cases\nSplit into small, easy pieces\nDefine one piece at a time\n\nThinking about use-cases before the goal helps you focus on the small, easy-to-solve pieces (exact problem at hand, limit the scope of the problem) without getting bogged down in any grandiose, big-picture ideas.\nEncapsulation\nIsolate unrelated concerns.\nHide changing things.\nPython details:\nUse the @property & @var.setter decorators for getters & setters.\n@classmethod decorator for different constructors & other methods that work on the class but not instances of the class.\n\n\nEnvironment variables\ncollections.ChainMap: use it to prioritize program options.\nos.environ to access shell environment variables.\nDefaults = some dict\ncombined = ChainMap(cmdline_args, os.environ, defaults)\nEquivalent of stringing together dictionary.update but in reverse\n\n\n\nStructuring code for readability: Trey Hunner blog post: craft your python like poetry.\nLow barrier to entry. Make your code usable & accessible to lots of people.\nMake a runnable sample\nKeep it short; one command if possible.\nslick example: curl URL/quickstart.sh | bash (see slides for contents of quickstart.sh)\n\nClean up after running\nRun it multiple times in a row & it does the exact same thing every time\n\n\nIntro to Design Patterns (Jeffrey Carver)\nChain of responsibility\nCommon interface to handle requests, but user doesn‚Äôt need to know which specific method handles the request.\n\nCreational pattern: Builder\nCreate various representations of the same object. Abstract construction steps with different implementations of methods for different object variants.\n\nStructural pattern: Proxy\nOnly load something when you actually need it if it takes a long time to load or is expensive to create. e.g.¬†when loading webpage, it‚Äôll display the text before images have finished loading, with blank placeholder where image will load.\n\nMore resources\n‚ÄúGang of four‚Äù original book on design patterns\ntoptal.com python design patterns book\n\nBasics of packaging Python programs (Kyle Niemeyer)\nModule: any python file that contains definitions & statements.\nPackage: a collection of modules in the same directory.\nMust contain the __init__.py file. (Except for namespace packages‚Ä¶)\nOften this file is empty.\nPython executes this file before anything else when imported.\n\nCan contain subdirectories with ‚Äúsubmodules‚Äù containing more Python files and another __init__.py file.\nTests subdirectory for test files (more on pytest later).\n\nLots of different ways to import modules.\nKyle‚Äôs preferred way: explicit relative imports\nUses dot notation (. for current path, .. for one level up)\n\n\nDON‚ÄôT REINVENT THE WHEEL\nRely on the standard library, numpy, scipy, etc.\n\nmain() & __main__ (Bryan Weber, writes for RealPython)\nCan use a module both as a module AND a script.\nmain() is the entry point to the program.\nImport guard example: realpython.com/python-main-function\n__main__.py: special use case to execute your package as a script. e.g.¬†pip.\n\nPackage management\npip to install packages on PyPI or from source.\n-e flag for development version.\n\nThe setup.py file (at same level as source directory) tells pip how to install your package.\nSee slides for example use.\n\nSee Kyle‚Äôs ‚Äúbetter example‚Äù slide for cool use of path.abspath & path.join with here variable (kinda like R‚Äôs here pkg)\nKeep a Changelog\nSemantic versioning (PEP 440)\nMAJOR.MINOR.PATCH\n\nProblem with setup.py: could have malicious code.\nPyPA has come up with pyproject.toml & flit to get around that. Also easier than using setup.py.\nAlso look into cookiecutter templates.\n\n\nThink about this at the very beginning so you don‚Äôt have to re-organize everything later.\nDay 2\nCollaboration with Git and GitHub (Karthik Ram)\nWorkflows\nCentralized workflow\nOnly works for really small projects\nEveryone just commits to master üò¨\n\nFeature branching workflow\nAll work in a feature branch (not master).\nStart a pull request before merging to master.\nDelete branches after they‚Äôre merged.\n\nForking workflow\nOnly reason to fork is if you don‚Äôt have write access to someone else‚Äôs project / when you‚Äôre not a core contributor.\nCreate a PR when ready to merge.\n\n\nAlias git to hub\nExtensions to interface with GitHub from the command line.\nCreate a GitHub repo from a local git repo: git create username/reponame\nOpen up the repo in your browser: git browse\nOpen a new PR: git pull-request\nCompare 2 branches: git compare master..feature-branch\nIf you clone a repo but realize you wanted to fork it: git fork\n\nOn branches:\nA branch is just a pointer to a commit. Commits are linked nodes.\n\nUse pull requests as much as possible.\nFosters code review.\nFacilitates discussion.\nCan use continuous integration to run tests automatically.\nSomeone else should merge your code into master so two sets of eyeballs review each feature.\nPick one or two people to do a technical review & an end-user review.\n\nInstead of creating a merge commit, could use rebase to squash all the commits from that branch into one.\nNEVER SEND A PULL REQUEST FROM MASTER.\nMaster branches will become incompatible.\nGitHub now warns you if you attempt to do this.\n\nNever send a large pull request without notice.\nRead the contributing doc.\nCommon practice is to ask whether the maintainers want the feature before you work on it.\nPull requests should be small, digestible changes.\nMake each unit of code simple enough for someone to review & accept.\n\n\n\nTips:\nAlways git pull before you start new work.\nKeep branch names descriptive.\nGenerously use branches, but delete them when you‚Äôre done.\nUse the hub extension to make your life easier.\n\nGit Exercises (James Howison)\nGroup activity here.\nPull requests are communication; make them digestible.\nNote: any time you edit files, that‚Äôs a feature, so you should always do that in a branch.\nMaintainer as developer AND champion of the community.\nCreate a welcoming & active environment.\nHow long ago was the last commit is really important: is the project active?\n‚ÄúTurn the music on ‚Äî make it feel like a party!‚Äù\n\nEven when you‚Äôre working with people face-to-face, you should document discussions on GitHub.\n\nHow to split pull requests.\n\n\nWe‚Äôre learning so many useful tips & tricks for research software sustainability at #urssi_winterschool ‚Ä¶and having fun along the way! pic.twitter.com/FMApXXj9wL\n\n‚Äî Kelly Sovacool (@kelly_sovacool) December 19, 2019\n\nSoftware Testing and Continuous Integration (Kyle Niemeyer)\nHow do you know your code gives the right answers? ‚Ä¶what about after you make changes to the code?\nWhen: ALWAYS\nWhere: external test suite\ne.g.¬†inside tests/ subdir in package repo.\nSome tests are better than no tests. But a rigorous test suite is best!\n\nWhy: make sure our results are trustworthy.\nIt‚Äôs really easy to make subtle mistakes.\nHelps us know that a PR won‚Äôt break anything.\nUnit tests are good examples of how a package works.\n\nWhat and how\nTests compare expected vs observed outputs for known inputs.\nYou don‚Äôt have to have a function written in order to write a test.\nUse assertions (e.g.¬†assert exp == obs).\nUse math.isclose() or np.allclose() to get around floating point precision.\nUse pytest package.\n-s to keep standard output.\n-k to run tests matching a substring.\n-q run specific test file & test function.\n\n\nWhat cases to test\nInterior: precise values don‚Äôt matter (just test one of these).\nEdge: beginning or end of range of inputs (test all of these).\nCorner cases: 2 or more edge cases that intersect.\n\nPytest test generators\nDecorator to feed lots of inputs to one test function: @pytest.mark.parametrize\n\nTypes of tests\nUnit test: test individual functions & methods.\nHave to break up your code into small functions.\n\nIntegration test: verify that multiple pieces of the code work together.\nRegression test: confirm that new results match prior results (which are assumed correct).\n\nTest-driven development (TDD): write your tests before you implement the functions.\nMore tips\nTest for consistency with PEP8.\ne.g.¬†flake8: linter & style-checker. black auto-formatter (not mentioned by Kyle).\nPlugins for your favorite IDE to run it continuously.\n\nTest that exceptions are raised: pytest.raises(ExceptionClass)\nMocking\nReplace parts of the system with precisely controllable code to specify return values & throw exceptions.\n\n\nTest coverage\nPercentage of code (in number of lines) that are touched by tests.\n100% test coverage doesn‚Äôt guarantee that you catch all potential errors; it means every line of code is run by at least one test.\npytest-cov creates a coverage report.\ncodecov.io integrates with GitHub.\n\nContinuous integration\nEnsure all changes to your project pass tests through automated test & build process.\nServices: GitHub Actions, travis, CircleCI, AppVeyor, Jenkins (not mentioned by Kyle but used by mothur)\nAdd the CI badge to your readme: it signals that your tool is being actively maintained.\nSee PyTeCK as an example of useful badges & tests in the wild.\n\nGit Exercises ctd (James Howison)\nThe ‚Äúsplit a pull request‚Äù activity.\nLearnGitBranching visualizer.\nNote: git cherry-pick keeps the original author information. üòÑ\ngit rebase re-writes history to move the branch point. Obviates merge commits, instead makes them fast-forwards.\ngit rebase -i in interactive mode is a good idea. Allows you to squash commits and clean things up.\nDay 3\nCode Review (Jeffrey Carver)\nCode review augments testing, but doesn‚Äôt replace testing.\nEfficiency, readability, etc. can‚Äôt be tested for.\n\nThe purpose is to make the code better. Everyone makes mistakes. There‚Äôs no expectation that you‚Äôll do it exactly right the first time.\nBy doing code review, you save time down the road.\nGoals:\nTeam cohesion.\nGain shared understanding of the project.\nGet to know teammates skills‚Äô better.\n\nCode quality.\nFind problems early.\nGet different perspectives.\nConsistency & readability.\nMakes code easier to maintain.\n\nPersonal learning.\nReading other people‚Äôs code & having your code reviewed.\n\n\nMindset:\nDeveloper:\nRecognize that a code critique is not a personal attack. You are not your code.\nBe ready & willing to learn new things.\nExpect that there will be changes. Remove the fear of making mistakes.\nBe humble.\n\nReviewer:\nDon‚Äôt assume that your way is the best.\nMake positive comments, not only negative ones.\nUnderstand why the developer asked you to review the code.\nFocus on the code, not on the author.\nPick your battles.\n\n\nTechniques\nPrioritize things that humans can spot that automated testing can‚Äôt.\nReadability\nAlgorithms\n\n\nHow we communicate matters (applies in all types of feedback-giving)\nAsk questions where possible.\ne.g.¬†‚ÄúHave you considered‚Ä¶‚Äù ‚Äì Maybe they have and there‚Äôs a good reason for it.\n\nNo personal attacks. It‚Äôs about the code, not the person!\nBe as specific as possible about how the code could be improved instead of making general statements.\nPut yourself in others‚Äô shoes.\nIf you wouldn‚Äôt want to get the comment, you probably shouldn‚Äôt give it to someone else.\n\nExplain why you‚Äôre making the suggestion.\n\nChecklist\nBefore you ask someone to review your code:\nWrite tests.\nMake sure the code runs & passes the tests.\nWrite comments & other documentation.\nDocument any weird edge cases & work-arounds\n\nFollow the style guide.\n\nWhen you review someone else‚Äôs code:\nComments are understandable & appropriate.\nDRY up repetitive code.\nCode runs & passes tests.\nExceptions are handled appropriately.\n\n\nBest practices\nCommunicate goals of code review.\nDo it early & often.\nReview a small amount of code.\nIf it takes longer than 60 minutes to review, that‚Äôs too much.\n\nEstablish a process for what to do after reviews.\nIs it a hard gate that you have to make the reviewer happy, or are they just suggestions you could choose not to follow?\n\n\nIssues you might identify in code review\nInconsistent style\nInefficiency\nUnvalidated inputs\nLack of exception handling\n\nWhy is code review important for research software specifically?\nJust like peer-reviewing publications, we want to make sure the code underlying the science is sound.\nScience depends on the correctness of your code.\nHelp spread best-practices & high-level understanding in the scientific community.\nResults may not always be known. There‚Äôs not always ‚Äúground truth‚Äù (e.g.¬†in simulations).\n\nGitHub-specific tips: using Pull Requests for code review (examples: pr-omethe-us/PyKED & astropy) (Kyle Niemeyer)\nUse pull request templates.\nCould enforce check boxes like which issue(s) it resolves, that test cases were added, etc.\n\nEasily view file diffs & add comments right alongside the code. Facilitates conversation.\nYou can leave comments at multiple lines.\nMake suggestions for small, easy changes. There‚Äôs an ‚Äúinsert suggestion‚Äù button! (Don‚Äôt do this for design changes.)\n\nUnder settings > branches, you can protect branches\ne.g.¬†require that a PR has to be reviewed before merging into master.\nMore on code owners in github docs\n\nTool: octobox.io for managing GitHub notifications.\n\nOpen Science and Software Citation (Kyle Niemeyer)\nTLDR: if you make your code public, pick a license and put a LICENSE file in your repo.\nCopyright\nFacts & ideas are not copyrightable.\nExpressions of ideas are copyrightable.\nRight of first publication: goes to the first creator even if not explicitly specified.\nYou should include a license with all publicly available software code so people know how they can (or can‚Äôt) use it.\nOr, you can explicitly put work into the public domain, then it‚Äôs free for anyone & everyone to use & modify.\n\n\nSoftware Licenses\nTypes:\nProprietary\nFree/open source (FOSS, FLOSS, OSS)\nPermissive: BSD 3-clause, MIT\nCopyleft: GPL (the license is ‚Äúviral‚Äù)\n\n\nPick an existing license; don‚Äôt make your own!\nchoosealicense.com\nOpen Source Initiative (OSI) Licenses\nTo call your work ‚Äúopen-source‚Äù, you have to release it under one of the OSI licenses.\n\n\nNon-software: Creative Commons\nCodes:\nBY: Attribution (similar to permissive)\nSA: ShareAlike (similar to copyleft)\nND: NoDerivatives\nNC: NonCommercial\n\ne.g.¬†CC BY, CC BY-SA\nCC0: like the public domain version of creative commons.\n\nMore concepts\nPatents: cover ideas & concepts (which copyright doesn‚Äôt).\nTrademarks: symbols that represent a business or organization.\nExport control: gov‚Äôt may forbid transfer of code/data/ideas to another country or foreign national.\nHIPAA: cannot share human patient data.\n\nArchiving & Citing Software\nServices: Zenodo, figshare, something within your University‚Äôs library (UMich has one)\nArchives your stuff forever and makes it citable with a DOI.\nfigshare: company, for-profit‚Ä¶\nZenodo: run by CERN. Will be around as long as the EU exists.\nFree! Good file size limits.\nConnects with GitHub! When you turn on Zenodo for your repo, it creates a new DOI when you cut a new release.\n\n\nWithout proper citations, your work is not reproducible.\nAcademia relies on citations for credit.\nPaper: Software Citation Principles\nSoftware should be ‚Äúfirst-class‚Äù citations just like other publications.\nHow? name, author(s), DOI or other persistent identifier.\nA GitHub link is not a persistent identifier, but it‚Äôs better than nothing.\n\nIf there‚Äôs a paper describing it, cite both the paper & the code DOI.\n\nHow can we make our software easily citable?\nCreate a DOI (e.g.¬†via Zenodo)\nInclude a CITATION file in your GitHub repo.\n\nTool in development: cite as (James Howison)\nWeb scraper to find the right citation given a package name or website.\n\n\nReproducibility\nrepro-packs (Kyle Niemeyer)\nLorena Barbra: ‚Äúreproducibility packages (repro-pack)‚Äù ‚Äì packages associated with papers shared under CC-BY.\nProduce a single repro-pack for an entire paper\ncontaining:\nCode, results, input data (if small enough)\nFigures (vector format)\nConfig file, etc\n\nUpload to FigShare/Zenodo under CC-BY license.\nCite using the resulting DOI in the associated papers.\n\nBenefits\nImprove reproducibility & impact of your work.\nReviewers love it.\nLets you reuse your figures without violating a journal copyright.\nWhen published, the journal (one that isn‚Äôt open access) owns the paper & everything in it that isn‚Äôt licensed from somewhere else.\n\n\nCan include an appendix with statement about the availability of material. Or put it in the methods section.\nResearch compendium: make your paper like a package so it‚Äôs easily-installable. Uses lightweight packaging structure.\n\nrOpenSci (Karthik Ram)\nrOpenSci: Scientific software for R. Helping researchers write sustainable software tools.\nsoftware-review: rOpenSci Software Peer Review of community-contributed packages\nJOSS got started when rOpenSci realized the need extends beyond R packages.\nrOpenSci‚Äôs dev-guide\nPyOpenSci recently got started as the Python version of ROpenSci. (David Nicholson)\n\nJOSS: Journal of Open Source Software (Kyle Niemeyer)\nOpen, no fees.\nIf you‚Äôve already licensed your code & have good documentation, it should take under an hour to submit to JOSS.\nVery short paper to describe the software.\nAll the conversation happens on GitHub. Uses same structure as JOSE (Journal of Open Source Education).\nQuestions from the audience: when to submit as a package (e.g.¬†to JOSS) versus in a repro-pack (to your society journal)?\nIf anyone else would ever use it, it should probably be a package.\nIf the code is only used for creating a paper, it should just be in the repro-pack.\nIf your goal is to write a methods paper, it probably wouldn‚Äôt go to JOSS.\nIf you have the option to submit to a domain journal, do that first instead of JOSS. (Karthik‚Äôs take)\nJOSS is meant to fill in the gap for people who don‚Äôt have a place to publish their software.\n\n\nThis is for getting research credit. But you still need to cite the specific version you used (e.g.¬†from Zotero) for reproducibility purposes.\n\nSidney Bell at the Chan Zuckerberg Initiative.\nCZI started funding scientific software.\nfoundational packages (e.g.¬†scikit-learn, matplotlib, pandas).\nbiology domain-specific packages.\n\nFirst cycle of funding awarded. Second round closes in Feb.\nFunding awarded to organizations (e.g.¬†NumFocus, Universities), not people.\n\nDocumentation (Kyle Niemeyer)\nValue of documentation.\nThe value & extent of your work if it‚Äôs understandable by your colleagues.\nProvides provenance for your scientific process.\nDemonstrates your skill & professionalism.\n‚ÄúA love-letter that you write to your future self.‚Äù\n\nIt‚Äôs easier than you think!\nTypes:\nUser & developer guides\nREADME file accompanied by LICENSE, CITATION, CHANGELOG, etc.\n\nCode comments\ndocstring\nWrite them for functions & classes.\nAvailable within Python via help() & easy to parse by Sphinx.\n\nin-line\nBad: polluting the code with unnecessary information that‚Äôs already evident from reading the code.\nGood: use sparingly to explain reasons behind choices & complicated sections.\n\n\nSelf-documenting code\nIntelligently name things that tells you why it exists, what it does, and how it‚Äôs used.\nWrite really simple functions that do only one thing.\n‚ÄúA function should have a function, not multiple functions.‚Äù\n\nFollow consistent style.\n\nGenerated API documentation\n\nTools\nSphinx: automatically generate documentation\nSet it up with CI to automatically build your documentation website when you make changes.\nWriting docstrings that are compatible with Sphinx:\nStyles: NumPy, Google, reStructuredText‚Ä¶ (note: PyCharm can insert doc scaffolds automatically).\nSpecify parameters, returns, & include a short description.\n\nEasy to get started quickly. See slides for more details. # at top-level of repo, same level as package dir   mkdir docs/   cd docs/   sphinx-quickstart   make html\n\ndoctr: auto-deploy docs to GitHub pages using TravisCI.\nRead the Docs to host your documentation.\nSimple example: Kyle‚Äôs MechE course\nMore complex example: astropy\n\n\n",
    "preview": {},
    "last_modified": "2020-12-01T12:30:18-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2019-05-15-bioinf-resources/",
    "title": "Bioinformatics Resources",
    "description": "Resources for Bioinformatics Software Development & Data Analysis",
    "author": [],
    "date": "2019-05-15",
    "categories": [
      "Bioinformatics",
      "Software Development",
      "Data Analysis",
      "Reproducibility",
      "Python",
      "R",
      "git"
    ],
    "contents": "\n\nContents\nProgrammingShell\nGit\nPython\nR\n\nReproducibilityProject organization\nLiterate programming\nDocumentation\n\nEditors\nMisc.\n\nI found myself sending some of the same links over and over again to people who asked questions related to bioinformatics. So it was time to compile all the links in one convenient place!\nAll of the resources linked below are free unless otherwise noted. This isn‚Äôt intended to be an exhaustive list of all the resources available, just some of the ones I have come across and have found useful.\nLast updated: 2019-09-23\nProgramming\nSoftware Carpentry: Intro lessons on the Unix shell, git, R, & Python.\nLangmead Lab teaching materials: cover classic bioinformatics algorithms.\nAdvent of Code: small programming puzzles.\nStepik Bioinformatics Contest.\nShell\nIntroduction to the Unix Shell - Software Carpentry\nExtra Unix Shell Material - Software Carpentry\nIntroduction to the Command Line for Genomics - Data Carpentry\nOh My ZSH!: framework for managing your zsh configuration. I switched from bash to zsh and haven‚Äôt looked back! (Why zsh is cooler than your shell)\nGit\nSoftware Carpentry lesson\ngit documentation\nVersion Control with Git - Software Carpentry\nLearn Git Branching: interactive git visualizer\nHow to Write a Git Commit Message - Chris Beams\nLink your university email to GitHub to get pro/education features.\nAll users (Pro or free) get free unlimited private repositories on GitHub.\n\nGitKraken has a nice GUI for interacting with git, GitHub, GitLab, etc. (Note that this is a referral link to be entered to win a Nintendo Switch.)\nPython\nSoftware Carpentry lesson\nProject Rosalind: learn Python & practice solving bioinformatics problems.\nGWC Code demos: introductory Python demos - Girls Who Code @ UM-DCMB\nGWC Challenge Questions: practice solving problems - Girls Who Code @ UM-DCMB\nPython For Everybody course on Coursera (free for UMich students) - Charles Severance\nObject-Oriented Programming (OOP) in Python tutorial - RealPython\nBooks:\nPython Data Science Handbook - Jake VanderPlas\nAutomate the Boring Stuff with Python - Al Sweigart\nThink Python: How to Think Like a Computer Scientist - Allen Downey\nDive Into Python 3 - Mark Pilgrim\nObject-Oriented Programming in Python - University of Cape Town\n\nVideos:\nOffice Hours for BIOINF 529: Bioinformatic Concepts & Algorithms - Marcus Sherman\nTransforming Code into Beautiful, Idiomatic Python - Raymond Hettinger\nBeyond PEP 8 ‚Äì Best practices for beautiful intelligible code - Raymond Hettinger\n\nR\nSoftware Carpentry lesson\nRStudio‚Äôs interactive tutorials\nCheatsheets by RStudio\nRiffomonas minimalR: Intro to R tutorial with applications in microbiology - Pat Schloss\nWhat is the Tidyverse?\nGetting started with the Tidyverse\nBooks:\nR for Data Science - Hadley Wickham\nMastering Software Development in R - Roger Peng, Sean Kross, & Brooke Anderson\nAdvanced R - Hadley Wickham\nR Packages - Hadley Wickham\nWhat they forgot to teach you about R - Jenny Bryan & Jim Hester\nHappy Git and GitHub for the useR - Jenny Bryan & Jim Hester\nFundamentals of Data Visualization - Claus O. Wilke\nAn Introduction to Statistical Learning with Applications in R - Gareth James, Daniela Witten, Trevor Hastie, & Robert Tibshirani\n\nReproducibility\nRiffomonas reproducible research tutorial - Pat Schloss\nSnakemake: Python-based workflow management system.\nconda: package, dependency, & environment manager.\ncheatsheet\nTutorial: conda on the cluster - Will Close\n\nHow to Name Files - Jenny Bryan\nProject organization\nNoble WS. A quick guide to organizing computational biology projects. 2009. PLOS Comput Biol. doi: 10.1371/journal.pcbi.1000424.\nScientific project template.\ncookiecutter project templating tool.\nHow to Name Files - Jenny Bryan\nLiterate programming\nR Markdown\nHow I use R Markdown to document my bioinformatics analyses - Rachael Lappan\nRMarkdown for writing reproducible scientific papers - Mike Frank & Chris Hartgerink\nR Markdown: The Definitive Guide - Yihui Xie, J. J. Allaire, Garrett Grolemund\nCommunicating with R Markdown\nJupyter\nJupyter Notebooks for Performing and Sharing Bioinformatics Analyses - Jonathan Dursi\nJupyterLab Documentation\nGoogle Colab - free Jupyter notebook environment in the cloud.\nWe use this for teaching Python for data science in our Girls Who Code club.\n\nDocumentation\nLee BD (2018) Ten simple rules for documenting scientific software. PLoS Comput Biol 14(12): e1006561. doi: 10.1371/journal.pcbi.1006561.\ndocopt: easily create & parse command-line interfaces. Available for Python, R, C++, & more.\nSphinx for creating documentation.\nRead the Docs for hosting documentation.\nWriting R package documentation.\npkgdown: build a website for your R package.\nEditors\nAtom: text editor. Additional packages for atom:\nAutosave on change\nMarkdown Preview\nMarkdown TOC\nLanguage LaTeX\n\nPyCharm: IDE for Python.\nThe community edition is free, or link your university email to get the pro version for free.\nSupports Snakemake syntax highlighting & Jupyter notebooks.\n\nRStudio: IDE for R.\nKite: AI autocomplete for Python. Works in Atom, PyCharm, Vim, & more.\nMisc.\ncsvkit: command-line tool for working with and converting to CSV format from Excel, JSON, etc.\nHypothesis Python testing module.\n\n\n\n",
    "preview": {},
    "last_modified": "2020-12-01T12:30:18-05:00",
    "input_file": {}
  }
]
